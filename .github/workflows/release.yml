name: Release

on:
  push:
    tags:
      - 'v*'  # Triggers on version tags like v1.0.0, v2.1.3, etc.

permissions:
  contents: write  # Required for creating releases

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.get_version.outputs.tag_name }}
      version: ${{ steps.get_version.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get version from tag
      id: get_version
      run: |
        TAG_NAME=${GITHUB_REF#refs/tags/}
        VERSION=${TAG_NAME#v}
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Tag: $TAG_NAME, Version: $VERSION"

    - name: Extract changelog for this version
      run: |
        VERSION=${{ steps.get_version.outputs.version }}
        
        # Create a script to extract changelog
        cat << 'EOF' > extract_changelog.py
        import sys
        
        def extract_changelog(version):
            try:
                with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                
                # Find the version section
                start_index = -1
                for i, line in enumerate(lines):
                    if f'## [{version}]' in line:
                        start_index = i
                        break
                
                if start_index == -1:
                    return f"Release {version}\n\nChanges and improvements in this version."
                
                # Extract content until next ##
                content_lines = []
                for i in range(start_index + 1, len(lines)):
                    line = lines[i]
                    if line.startswith('## [') and f'[{version}]' not in line:
                        break
                    content_lines.append(line.rstrip())
                
                content = '\n'.join(content_lines).strip()
                
                if len(content.strip()) < 10:
                    return f"Release {version}\n\nChanges and improvements in this version."
                
                return content
                
            except Exception as e:
                return f"Release {version}\n\nError reading changelog: {str(e)}"
        
        if __name__ == "__main__":
            version = sys.argv[1]
            changelog = extract_changelog(version)
            print(changelog)
        EOF
        
        python extract_changelog.py "$VERSION" > release_notes.txt
        
        # Verify the file has content
        if [ ! -s release_notes.txt ]; then
          echo "Release $VERSION" > release_notes.txt
          echo "" >> release_notes.txt
          echo "Changes and improvements in this version." >> release_notes.txt
        fi

    - name: Create Release
      uses: softprops/action-gh-release@v2
      id: create_release
      with:
        tag_name: ${{ steps.get_version.outputs.tag_name }}
        name: "CamLoader ${{ steps.get_version.outputs.tag_name }}"
        body_path: release_notes.txt
        draft: false
        prerelease: ${{ contains(steps.get_version.outputs.tag_name, '-') }}
        token: ${{ secrets.GITHUB_TOKEN }}
        generate_release_notes: false

  build-linux-x86_64:
    runs-on: ubuntu-22.04  # Use modern runner but build for maximum compatibility
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'  # Use Python 3.9 for better GLIBC compatibility

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3-tk python3-dev build-essential xvfb patchelf fuse libfuse2
        
        # Download AppImage tools for maximum compatibility
        wget https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
        chmod +x appimagetool-x86_64.AppImage
        sudo mv appimagetool-x86_64.AppImage /usr/local/bin/appimagetool

    - name: Install Python dependencies
      run: |
        python3 -m pip install --upgrade pip
        pip3 install -r requirements.txt
        pip3 install pyinstaller staticx

    - name: Create x86_64 executable
      run: |
        # Set display for headless build
        export DISPLAY=:99
        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
        
        # Create PyInstaller spec for single executable
        cat << 'EOF' > camloader.spec
        # -*- mode: python ; coding: utf-8 -*-
        import sys
        import os
        from pathlib import Path
        
        src_path = Path.cwd() / 'src'
        sys.path.insert(0, str(src_path))
        
        datas = []
        if os.path.exists('data'):
            datas.append(('data', 'data'))
        
        a = Analysis(
            ['src/main.py'],
            pathex=[str(src_path)],
            binaries=[],
            datas=datas,
            hiddenimports=[
                'tkinter', 'tkinter.ttk', 'tkinter.filedialog', 'tkinter.messagebox',
                'tkinter.constants', 'tkinter.font', '_tkinter',
                'PIL', 'PIL.Image', 'PIL.ImageTk', 'PIL._tkinter_finder',
                'cv2', 'cv2.cv2', 'numpy', 'logging', 'json',
                'threading', 'subprocess', 'pathlib', 'datetime', 'platform',
                'pkg_resources', 'pkg_resources.py2_warn'
            ],
            hookspath=[],
            hooksconfig={},
            runtime_hooks=[],
            excludes=['matplotlib', 'scipy', 'pandas', 'IPython'],
            win_no_prefer_redirects=False,
            win_private_assemblies=False,
            cipher=None,
            noarchive=False,
        )
        
        pyz = PYZ(a.pure, a.zipped_data, cipher=None)
        
        exe = EXE(
            pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [],
            name='camloader-linux-x86_64',
            debug=True,
            bootloader_ignore_signals=False,
            strip=False,
            upx=False,
            upx_exclude=[],
            runtime_tmpdir=None,
            console=True,
            disable_windowed_traceback=False,
            argv_emulation=False,
            target_arch=None,
            codesign_identity=None,
            entitlements_file=None,
        )
        EOF
        
        # Build the executable with compatibility flags
        python3 -m PyInstaller camloader.spec --clean --noconfirm --log-level=DEBUG
        
        # Try to create a more compatible version using staticx
        echo "=== Creating statically linked version ==="
        if staticx dist/camloader-linux-x86_64 dist/camloader-linux-x86_64-static 2>/dev/null; then
            echo "Static version created successfully"
            mv dist/camloader-linux-x86_64-static dist/camloader-linux-x86_64
            echo "Replaced with static version"
        else
            echo "Static linking failed, trying AppImage approach..."
            
            # Create AppDir structure for AppImage
            mkdir -p AppDir/usr/bin
            cp dist/camloader-linux-x86_64 AppDir/usr/bin/
            
            # Create AppImage desktop entry
            cat > AppDir/camloader.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=CamLoader
        Exec=camloader-linux-x86_64
        Icon=camloader
        Categories=Multimedia;Video;
        EOF
            
            # Create a simple icon (text-based)
            mkdir -p AppDir/usr/share/pixmaps
            cat > AppDir/usr/share/pixmaps/camloader.svg << EOF
        <svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
          <rect width="64" height="64" fill="#2196F3"/>
          <text x="32" y="38" fill="white" text-anchor="middle" font-family="Arial" font-size="16">CAM</text>
        </svg>
        EOF
            
            # Create AppRun script
            cat > AppDir/AppRun << EOF
        #!/bin/bash
        cd "\$(dirname "\$0")"
        exec ./usr/bin/camloader-linux-x86_64 "\$@"
        EOF
            chmod +x AppDir/AppRun
            
            # Build AppImage if tools are available
            if command -v appimagetool >/dev/null 2>&1; then
                echo "Creating AppImage..."
                appimagetool AppDir dist/camloader-linux-x86_64.AppImage 2>/dev/null || echo "AppImage creation failed"
                if [ -f dist/camloader-linux-x86_64.AppImage ]; then
                    mv dist/camloader-linux-x86_64.AppImage dist/camloader-linux-x86_64
                    echo "AppImage created successfully"
                fi
            else
                echo "AppImage tools not available, using original binary"
            fi
        fi
        
        # Create additional compatibility info
        echo "=== Build Environment Info ==="
        lsb_release -a
        python3 --version
        ldd --version
        
        # Create a debug wrapper script
        cat << 'EOF' > dist/camloader-debug.sh
        #!/bin/bash
        # Debug wrapper for camloader
        echo "=== CamLoader Debug Startup ==="
        echo "Architecture: $(uname -m)"
        echo "Distribution: $(lsb_release -d 2>/dev/null || echo 'Unknown')"
        echo "Kernel: $(uname -r)"
        echo "Python in PATH: $(which python3 2>/dev/null || echo 'Not found')"
        echo "Current directory: $(pwd)"
        echo "Executable permissions: $(ls -la camloader-linux-x86_64)"
        
        echo "=== GLIBC Version Check ==="
        echo "System GLIBC: $(ldd --version | head -1)"
        if command -v getconf >/dev/null 2>&1; then
            echo "GNU_LIBC_VERSION: $(getconf GNU_LIBC_VERSION 2>/dev/null || echo 'Unknown')"
        fi
        
        echo "=== Checking dependencies ==="
        
        # Check for required libraries
        if command -v ldd >/dev/null 2>&1; then
            echo "Library dependencies:"
            ldd camloader-linux-x86_64 2>/dev/null || echo "ldd check failed"
        fi
        
        echo "=== Attempting to start CamLoader ==="
        exec ./camloader-linux-x86_64 "$@"
        EOF
        
        chmod +x dist/camloader-debug.sh
        
        # Verify and test
        ls -la dist/
        chmod +x dist/camloader-linux-x86_64
        
        # Test if the executable can at least start
        echo "=== Testing executable startup ==="
        file dist/camloader-linux-x86_64
        ldd dist/camloader-linux-x86_64 || echo "ldd check failed - might be static"

    - name: Upload x86_64 executable
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.create-release.outputs.tag_name }}
        files: |
          dist/camloader-linux-x86_64
          dist/camloader-debug.sh
        token: ${{ secrets.GITHUB_TOKEN }}

  build-source-package:
    runs-on: ubuntu-latest
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.9'  # Use Python 3.9 for better GLIBC compatibility

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build setuptools wheel

    - name: Build source packages
      run: |
        python -m build --sdist --wheel
        ls -la dist/

    - name: Upload source packages
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.create-release.outputs.tag_name }}
        files: |
          dist/*.tar.gz
          dist/*.whl
        token: ${{ secrets.GITHUB_TOKEN }}