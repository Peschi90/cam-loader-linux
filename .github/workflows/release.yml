name: Release

on:
  push:
    tags:
      - 'v*'  # Triggers on version tags like v1.0.0, v2.1.3, etc.

permissions:
  contents: write  # Required for creating releases

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      tag_name: ${{ steps.get_version.outputs.tag_name }}
      version: ${{ steps.get_version.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for changelog

    - name: Get version from tag
      id: get_version
      run: |
        TAG_NAME=${GITHUB_REF#refs/tags/}
        VERSION=${TAG_NAME#v}
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Tag: $TAG_NAME, Version: $VERSION"

    - name: Extract changelog for this version
      id: changelog
      run: |
        VERSION=${{ steps.get_version.outputs.version }}
        
        # Create a script to extract changelog
        cat << 'EOF' > extract_changelog.py
        import sys
        import re
        
        def extract_changelog(version):
            try:
                with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                
                print(f"Looking for version: {version}", file=sys.stderr)
                
                # Manual approach - find the line and extract content until next ##
                start_index = -1
                for i, line in enumerate(lines):
                    if f'## [{version}]' in line:
                        start_index = i
                        print(f"Found version at line {i}: {line.strip()}", file=sys.stderr)
                        break
                
                if start_index == -1:
                    print("Version not found", file=sys.stderr)
                    return f"Release {version}\n\nChanges and improvements in this version."
                
                # Extract content from next line until next ## or end
                content_lines = []
                for i in range(start_index + 1, len(lines)):
                    line = lines[i]
                    if line.startswith('## [') and f'[{version}]' not in line:
                        print(f"End section found at line {i}: {line.strip()}", file=sys.stderr)
                        break
                    content_lines.append(line.rstrip())
                
                # Join and clean
                content = '\n'.join(content_lines).strip()
                
                print(f"Extracted {len(content_lines)} lines, {len(content)} characters", file=sys.stderr)
                
                if len(content.strip()) < 10:
                    return f"Release {version}\n\nChanges and improvements in this version."
                
                return content
                
            except FileNotFoundError:
                print("CHANGELOG.md not found", file=sys.stderr)
                return f"Release {version}\n\nNo changelog file found."
            except Exception as e:
                print(f"Error reading changelog: {str(e)}", file=sys.stderr)
                return f"Release {version}\n\nError reading changelog: {str(e)}"
        
        if __name__ == "__main__":
            version = sys.argv[1]
            changelog = extract_changelog(version)
            print(changelog)
        EOF
        
        # Extract changelog and save to file
        echo "Extracting changelog for version: $VERSION"
        python extract_changelog.py "$VERSION" > release_notes.txt 2>changelog_debug.log
        
        # Show debug information
        echo "Debug output:"
        cat changelog_debug.log
        
        echo "Extracted release notes:"
        cat release_notes.txt
        
        # Verify the file has content
        if [ ! -s release_notes.txt ]; then
          echo "Warning: release_notes.txt is empty, creating fallback content"
          echo "Release $VERSION" > release_notes.txt
          echo "" >> release_notes.txt
          echo "Changes and improvements in this version." >> release_notes.txt
        fi

    - name: Create Release
      uses: softprops/action-gh-release@v2
      id: create_release
      with:
        tag_name: ${{ steps.get_version.outputs.tag_name }}
        name: "CamLoader ${{ steps.get_version.outputs.tag_name }}"
        body_path: release_notes.txt
        draft: false
        prerelease: ${{ contains(steps.get_version.outputs.tag_name, '-') }}
        token: ${{ secrets.GITHUB_TOKEN }}
        fail_on_unmatched_files: false
        generate_release_notes: false  # We provide our own release notes

    - name: Upload release notes artifact
      uses: actions/upload-artifact@v4
      with:
        name: release-notes
        path: release_notes.txt

  build-linux-executable:
    runs-on: ubuntu-latest
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'  # Use Python 3.11 for better compatibility

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          v4l-utils \
          python3-tk \
          python3-dev \
          build-essential \
          xvfb

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
        # Install additional dependencies for building
        pip install setuptools wheel

    - name: Create PyInstaller spec file
      run: |
        cat << 'EOF' > camloader.spec
        # -*- mode: python ; coding: utf-8 -*-
        import sys
        from pathlib import Path
        import os
        
        # Add src directory to Python path
        src_path = Path.cwd() / 'src'
        sys.path.insert(0, str(src_path))
        
        block_cipher = None
        
        # Check if data directory exists and include it if it does
        datas = []
        if os.path.exists('data'):
            datas.append(('data', 'data'))
        
        a = Analysis(
            ['src/main.py'],
            pathex=[str(src_path)],
            binaries=[],
            datas=datas,
            hiddenimports=[
                'tkinter',
                'tkinter.ttk',
                'tkinter.filedialog',
                'tkinter.messagebox',
                'PIL',
                'PIL.Image',
                'PIL.ImageTk',
                'cv2',
                'logging',
                'json',
                'threading',
                'subprocess',
                'pathlib',
                'datetime',
                'platform',
            ],
            hookspath=[],
            hooksconfig={},
            runtime_hooks=[],
            excludes=[],
            win_no_prefer_redirects=False,
            win_private_assemblies=False,
            cipher=block_cipher,
            noarchive=False,
        )
        
        pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
        
        exe = EXE(
            pyz,
            a.scripts,
            a.binaries,
            a.zipfiles,
            a.datas,
            [],
            name='camloader',
            debug=False,
            bootloader_ignore_signals=False,
            strip=False,
            upx=True,
            upx_exclude=[],
            runtime_tmpdir=None,
            console=False,  # Set to False for GUI application
            disable_windowed_traceback=False,
            argv_emulation=False,
            target_arch=None,
            codesign_identity=None,
            entitlements_file=None,
        )
        EOF

    - name: Build executable with PyInstaller
      run: |
        # Set display for headless build
        export DISPLAY=:99
        Xvfb :99 -screen 0 1024x768x24 &
        
        # Build the executable
        pyinstaller camloader.spec --clean
        
        # Verify the executable was created
        ls -la dist/
        
        # Test the executable (basic import test)
        echo "Testing executable..."
        timeout 10s ./dist/camloader --help || echo "Executable test completed (expected timeout for GUI)"

    - name: Create portable Linux package
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        PACKAGE_NAME="camloader-${{ needs.create-release.outputs.tag_name }}-linux-x86_64"
        
        # Create package directory
        mkdir -p "${PACKAGE_NAME}"
        
        # Copy executable
        cp dist/camloader "${PACKAGE_NAME}/"
        
        # Create launcher script
        cat << 'EOF' > "${PACKAGE_NAME}/camloader.sh"
        #!/bin/bash
        # CamLoader Launcher Script
        
        # Get the directory where this script is located
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        
        # Check for required system dependencies
        check_dependencies() {
            local missing_deps=()
            
            if ! command -v v4l2-ctl &> /dev/null; then
                missing_deps+=("v4l-utils")
            fi
            
            if [ ${#missing_deps[@]} -ne 0 ]; then
                echo "Warning: Missing system dependencies: ${missing_deps[*]}"
                echo "Please install them using your package manager:"
                echo "  Ubuntu/Debian: sudo apt install ${missing_deps[*]}"
                echo "  Fedora: sudo dnf install ${missing_deps[*]}"
                echo "  Arch: sudo pacman -S ${missing_deps[*]}"
                echo ""
                echo "CamLoader will start anyway, but camera functionality may be limited."
                echo ""
            fi
        }
        
        check_dependencies
        
        # Run the application
        cd "$SCRIPT_DIR"
        exec ./camloader "$@"
        EOF
        
        chmod +x "${PACKAGE_NAME}/camloader.sh"
        
        # Copy documentation
        cp README.md "${PACKAGE_NAME}/" 2>/dev/null || echo "README.md not found"
        cp LICENSE "${PACKAGE_NAME}/" 2>/dev/null || echo "LICENSE not found"
        cp CHANGELOG.md "${PACKAGE_NAME}/" 2>/dev/null || echo "CHANGELOG.md not found"
        
        # Create install script
        cat << 'EOF' > "${PACKAGE_NAME}/install.sh"
        #!/bin/bash
        # CamLoader Installation Script
        
        set -e
        
        INSTALL_DIR="/opt/camloader"
        BIN_DIR="/usr/local/bin"
        DESKTOP_DIR="/usr/share/applications"
        
        echo "Installing CamLoader..."
        
        # Check if running as root for system-wide installation
        if [[ $EUID -eq 0 ]]; then
            echo "Installing system-wide..."
            
            # Create installation directory
            mkdir -p "$INSTALL_DIR"
            
            # Copy files
            cp -r * "$INSTALL_DIR/"
            
            # Create symlink in bin directory
            ln -sf "$INSTALL_DIR/camloader" "$BIN_DIR/camloader"
            
            # Install desktop entry
            if [ -f camloader.desktop ]; then
                cp camloader.desktop "$DESKTOP_DIR/"
                update-desktop-database "$DESKTOP_DIR" 2>/dev/null || true
            fi
            
            echo "CamLoader installed successfully!"
            echo "Run 'camloader' from anywhere or find it in your applications menu."
            
        else
            echo "Installing for current user..."
            
            # User installation
            USER_BIN="$HOME/.local/bin"
            USER_DESKTOP="$HOME/.local/share/applications"
            
            mkdir -p "$USER_BIN" "$USER_DESKTOP"
            
            # Copy executable
            cp camloader "$USER_BIN/"
            
            # Install desktop entry
            if [ -f camloader.desktop ]; then
                sed "s|Exec=.*|Exec=$USER_BIN/camloader|" camloader.desktop > "$USER_DESKTOP/camloader.desktop"
                update-desktop-database "$USER_DESKTOP" 2>/dev/null || true
            fi
            
            echo "CamLoader installed successfully!"
            echo "Make sure $USER_BIN is in your PATH."
            echo "Run 'camloader' or find it in your applications menu."
        fi
        EOF
        
        chmod +x "${PACKAGE_NAME}/install.sh"
        
        # Create desktop entry
        cat << EOF > "${PACKAGE_NAME}/camloader.desktop"
        [Desktop Entry]
        Version=1.0
        Type=Application
        Name=CamLoader
        Comment=V4L2 Camera Parameter Controller
        Exec=${PACKAGE_NAME}/camloader
        Icon=camera-video
        Terminal=false
        Categories=AudioVideo;Video;Photography;
        Keywords=camera;v4l2;video;parameters;
        EOF
        
        # Create README for the package
        cat << 'EOF' > "${PACKAGE_NAME}/README_PACKAGE.txt"
        CamLoader Linux Package
        =======================
        
        This package contains a standalone executable version of CamLoader.
        
        Quick Start:
        1. Extract this package
        2. Run: ./camloader.sh
        
        System Installation:
        1. Run: sudo ./install.sh
        2. Use 'camloader' command from anywhere
        
        Manual Installation:
        1. Copy 'camloader' to a directory in your PATH
        2. Ensure v4l-utils is installed: sudo apt install v4l-utils
        
        Requirements:
        - Linux x86_64
        - v4l-utils package
        - Camera with V4L2 driver support
        
        For more information, see README.md
        EOF
        
        # Create tarball
        tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}/"
        
        # Create zip for alternative download
        zip -r "${PACKAGE_NAME}.zip" "${PACKAGE_NAME}/"
        
        # Show package contents
        echo "Created package: ${PACKAGE_NAME}"
        ls -la "${PACKAGE_NAME}/"
        echo "Archive size:"
        ls -lh "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}.zip"

    - name: Upload Linux package to release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.create-release.outputs.tag_name }}
        files: |
          camloader-${{ needs.create-release.outputs.tag_name }}-linux-x86_64.tar.gz
          camloader-${{ needs.create-release.outputs.tag_name }}-linux-x86_64.zip
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: linux-executable
        path: |
          dist/camloader
          camloader-${{ needs.create-release.outputs.tag_name }}-linux-x86_64.tar.gz
          camloader-${{ needs.create-release.outputs.tag_name }}-linux-x86_64.zip

  build-source-package:
    runs-on: ubuntu-latest
    needs: create-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build setuptools wheel

    - name: Build and identify packages
      run: |
        # Build both distributions
        python -m build --sdist --wheel
        
        # List built files for debugging
        echo "Built files:"
        ls -la dist/
        
        # Find the actual file names
        TARBALL_PATH=$(find dist/ -name "*.tar.gz" -type f | head -1)
        WHEEL_PATH=$(find dist/ -name "*.whl" -type f | head -1)
        
        echo "Found source tarball: $TARBALL_PATH"
        echo "Found wheel: $WHEEL_PATH"
      id: build_packages

    - name: Upload source and wheel to release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.create-release.outputs.tag_name }}
        files: |
          dist/*.tar.gz
          dist/*.whl
        token: ${{ secrets.GITHUB_TOKEN }}